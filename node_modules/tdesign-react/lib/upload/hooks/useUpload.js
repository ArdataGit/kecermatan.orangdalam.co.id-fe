/**
 * tdesign v1.7.1
 * (c) 2024 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../../_chunks/dep-9d06ffd4.js';
import { _ as _toConsumableArray } from '../../_chunks/dep-1336b163.js';
import { _ as _slicedToArray } from '../../_chunks/dep-be37289b.js';
import { useRef, useState, useMemo, useEffect } from 'react';
import { m as merge_1 } from '../../_chunks/dep-24ea85d3.js';
import { getTriggerTextField, getDisplayFiles, formatToUploadFile, validateFile, getFilesAndErrors, upload } from '../../_common/js/upload/main.js';
import { getFileList } from '../../_common/js/upload/utils.js';
import useControlled from '../../hooks/useControlled.js';
import useConfig from '../../hooks/useConfig.js';
import { useLocaleReceiver } from '../../locale/LocalReceiver.js';
import '../../_chunks/dep-e0a22ada.js';
import '../../_chunks/dep-8e2ab2c9.js';
import '../../_chunks/dep-5f0ec823.js';
import '../../_chunks/dep-44c20420.js';
import '../../_chunks/dep-f3c9f0b1.js';
import '../../_chunks/dep-f3f3df31.js';
import '../../_chunks/dep-9d4210ce.js';
import '../../_chunks/dep-bee1cff5.js';
import '../../_chunks/dep-3317a9f1.js';
import '../../_chunks/dep-33f13f9c.js';
import '../../_chunks/dep-0064325f.js';
import '../../_chunks/dep-7b4b8732.js';
import '../../_chunks/dep-d5932774.js';
import '../../_chunks/dep-ae0cbd35.js';
import '../../_chunks/dep-560d448e.js';
import '../../_chunks/dep-d5964765.js';
import '../../_chunks/dep-a1b2bf89.js';
import '../../_chunks/dep-933fa6aa.js';
import '../../_chunks/dep-f8d0dc23.js';
import '../../_chunks/dep-434ba20b.js';
import '../../_chunks/dep-88ade432.js';
import '../../_chunks/dep-cf209156.js';
import '../../_chunks/dep-dc6bd1bf.js';
import '../../_chunks/dep-19704ef8.js';
import '../../_chunks/dep-69145a1d.js';
import '../../_common/js/upload/xhr.js';
import '../../_common/js/log/log.js';
import '../../_chunks/dep-85cb268b.js';
import '../../_chunks/dep-911f9744.js';
import '../../_chunks/dep-c464989f.js';
import '../../_chunks/dep-23dea7e8.js';
import '../../_chunks/dep-f1d40d68.js';
import '../../_util/noop.js';
import '../../config-provider/ConfigContext.js';
import '../../_common/js/global-config/locale/zh_CN.js';
import '../../_chunks/dep-7ba5fe7d.js';
import 'dayjs';
import '../../_common/js/global-config/default-config.js';

function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function useUpload(props) {
  var inputRef = useRef();
  var disabled = props.disabled,
    autoUpload = props.autoUpload,
    isBatchUpload = props.isBatchUpload;
  var _useConfig = useConfig(),
    classPrefix = _useConfig.classPrefix;
  var _useLocaleReceiver = useLocaleReceiver("upload"),
    _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 2),
    globalLocale = _useLocaleReceiver2[0],
    t = _useLocaleReceiver2[1];
  var _useControlled = useControlled(props, "files", props.onChange),
    _useControlled2 = _slicedToArray(_useControlled, 2),
    uploadValue = _useControlled2[0],
    setUploadValue = _useControlled2[1];
  var xhrReq = useRef([]);
  var _useState = useState([]),
    _useState2 = _slicedToArray(_useState, 2),
    toUploadFiles = _useState2[0],
    setToUploadFiles = _useState2[1];
  var _useState3 = useState(""),
    _useState4 = _slicedToArray(_useState3, 2),
    sizeOverLimitMessage = _useState4[0],
    setSizeOverLimitMessage = _useState4[1];
  var _useState5 = useState({}),
    _useState6 = _slicedToArray(_useState5, 2),
    update = _useState6[0],
    forceUpdate = _useState6[1];
  var locale = useMemo(function () {
    return merge_1({}, globalLocale, props.locale);
  }, [globalLocale, props.locale]);
  var tipsClasses = "".concat(classPrefix, "-upload__tips ").concat(classPrefix, "-size-s");
  var errorClasses = [tipsClasses].concat("".concat(classPrefix, "-upload__tips-error"));
  var placeholderClass = "".concat(classPrefix, "-upload__placeholder");
  var triggerUploadText = useMemo(function () {
    var _uploadValue$;
    var field = getTriggerTextField({
      isBatchUpload: isBatchUpload,
      multiple: props.multiple,
      status: uploadValue === null || uploadValue === void 0 || (_uploadValue$ = uploadValue[0]) === null || _uploadValue$ === void 0 ? void 0 : _uploadValue$.status,
      autoUpload: autoUpload
    });
    return locale.triggerUploadText[field];
  }, [locale.triggerUploadText, uploadValue, props.multiple, isBatchUpload, autoUpload]);
  var _useState7 = useState(false),
    _useState8 = _slicedToArray(_useState7, 2),
    uploading = _useState8[0],
    setUploading = _useState8[1];
  var _useState9 = useState(uploadValue || []),
    _useState10 = _slicedToArray(_useState9, 2),
    displayFiles = _useState10[0],
    setDisplayFiles = _useState10[1];
  useEffect(function () {
    var files = getDisplayFiles({
      multiple: props.multiple,
      toUploadFiles: toUploadFiles,
      uploadValue: uploadValue ? _toConsumableArray(uploadValue) : [],
      autoUpload: autoUpload,
      isBatchUpload: isBatchUpload
    });
    setDisplayFiles(files);
  }, [props.multiple, toUploadFiles, uploadValue, autoUpload, isBatchUpload, update]);
  var uploadFilePercent = function uploadFilePercent(params) {
    var file = params.file,
      percent = params.percent;
    if (autoUpload) {
      var index = toUploadFiles.findIndex(function (item) {
        return file.raw === item.raw;
      });
      var newFiles = _toConsumableArray(toUploadFiles);
      newFiles[index] = _objectSpread(_objectSpread({}, newFiles[index]), {}, {
        percent: percent
      });
      setToUploadFiles(newFiles);
    } else {
      var _index = uploadValue.findIndex(function (item) {
        return file.raw === item.raw;
      });
      uploadValue[_index] = _objectSpread(_objectSpread({}, uploadValue[_index]), {}, {
        percent: percent
      });
      forceUpdate({});
    }
  };
  var updateProgress = function updateProgress(p, toFiles, trigger) {
    if (props.autoUpload) {
      setToUploadFiles(_toConsumableArray(toFiles));
    } else {
      setUploadValue(_toConsumableArray(uploadValue), {
        e: p.event,
        trigger: trigger,
        index: uploadValue.length,
        file: p.files[0]
      });
    }
  };
  var _onResponseError = function onResponseError(p, toFiles) {
    var _props$onOneFileFail;
    if (!p || !p.files || !p.files[0]) return;
    if (toFiles) {
      updateProgress(p, toFiles, "progress-fail");
    }
    var response = p.response,
      event = p.event,
      files = p.files;
    (_props$onOneFileFail = props.onOneFileFail) === null || _props$onOneFileFail === void 0 || _props$onOneFileFail.call(props, {
      e: event,
      file: files === null || files === void 0 ? void 0 : files[0],
      currentFiles: files,
      failedFiles: files,
      response: response
    });
  };
  var _onResponseProgress = function onResponseProgress(p, toFiles) {
    var _props$onProgress;
    updateProgress(p, toFiles, "progress");
    (_props$onProgress = props.onProgress) === null || _props$onProgress === void 0 || _props$onProgress.call(props, {
      e: p.event,
      file: p.file,
      currentFiles: p.files,
      percent: p.percent,
      type: p.type,
      XMLHttpRequest: p.XMLHttpRequest
    });
  };
  var _onResponseSuccess = function onResponseSuccess(p, toFiles) {
    if (props.multiple && !props.uploadAllFilesInOneRequest) {
      var _props$onOneFileSucce;
      updateProgress(p, toFiles, "progress-success");
      (_props$onOneFileSucce = props.onOneFileSuccess) === null || _props$onOneFileSucce === void 0 || _props$onOneFileSucce.call(props, {
        e: p.event,
        file: p.files[0],
        response: p.response
      });
    }
  };
  function getSizeLimitError(sizeLimitObj) {
    var limit = sizeLimitObj;
    return limit.message ? t(limit.message, {
      sizeLimit: limit.size
    }) : "".concat(t(locale.sizeLimitMessage, {
      sizeLimit: limit.size
    }), " ").concat(limit.unit);
  }
  var handleNotAutoUpload = function handleNotAutoUpload(toFiles) {
    var tmpFiles = props.multiple && !isBatchUpload ? uploadValue.concat(toFiles) : toFiles;
    if (!tmpFiles.length) return;
    setUploadValue(tmpFiles, {
      trigger: "add",
      index: uploadValue.length,
      file: toFiles[0],
      files: toFiles
    });
    setToUploadFiles([]);
  };
  var onFileChange = function onFileChange(files) {
    var _props$onSelectChange;
    if (disabled) return;
    (_props$onSelectChange = props.onSelectChange) === null || _props$onSelectChange === void 0 || _props$onSelectChange.call(props, _toConsumableArray(files), {
      currentSelectedFiles: formatToUploadFile(_toConsumableArray(files), props.format)
    });
    validateFile({
      uploadValue: uploadValue,
      files: _toConsumableArray(files),
      allowUploadDuplicateFile: props.allowUploadDuplicateFile,
      max: props.multiple ? props.max : 0,
      sizeLimit: props.sizeLimit,
      isBatchUpload: isBatchUpload,
      autoUpload: autoUpload,
      format: props.format,
      beforeUpload: props.beforeUpload,
      beforeAllFilesUpload: props.beforeAllFilesUpload
    }).then(function (args) {
      var _args$validateResult;
      if (((_args$validateResult = args.validateResult) === null || _args$validateResult === void 0 ? void 0 : _args$validateResult.type) === "BEFORE_ALL_FILES_UPLOAD") {
        var _props$onValidate;
        (_props$onValidate = props.onValidate) === null || _props$onValidate === void 0 || _props$onValidate.call(props, {
          type: "BEFORE_ALL_FILES_UPLOAD",
          files: args.files
        });
        return;
      }
      if (args.lengthOverLimit) {
        var _props$onValidate2;
        (_props$onValidate2 = props.onValidate) === null || _props$onValidate2 === void 0 || _props$onValidate2.call(props, {
          type: "FILES_OVER_LENGTH_LIMIT",
          files: args.files
        });
        if (!args.files.length) return;
      }
      if (args.hasSameNameFile) {
        var _props$onValidate3;
        (_props$onValidate3 = props.onValidate) === null || _props$onValidate3 === void 0 || _props$onValidate3.call(props, {
          type: "FILTER_FILE_SAME_NAME",
          files: args.files
        });
      }
      if (args.fileValidateList instanceof Array) {
        var _props$onWaitingUploa;
        var _getFilesAndErrors = getFilesAndErrors(args.fileValidateList, getSizeLimitError),
          sizeLimitErrors = _getFilesAndErrors.sizeLimitErrors,
          beforeUploadErrorFiles = _getFilesAndErrors.beforeUploadErrorFiles,
          toFiles = _getFilesAndErrors.toFiles;
        var tmpWaitingFiles = autoUpload ? toFiles : toUploadFiles.concat(toFiles);
        (_props$onWaitingUploa = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa === void 0 || _props$onWaitingUploa.call(props, {
          files: tmpWaitingFiles,
          trigger: "validate"
        });
        if (sizeLimitErrors[0]) {
          var _props$onValidate4;
          setSizeOverLimitMessage(sizeLimitErrors[0].file.response.error);
          (_props$onValidate4 = props.onValidate) === null || _props$onValidate4 === void 0 || _props$onValidate4.call(props, {
            type: "FILE_OVER_SIZE_LIMIT",
            files: sizeLimitErrors.map(function (t2) {
              return t2.file;
            })
          });
        } else {
          setSizeOverLimitMessage("");
          if (beforeUploadErrorFiles.length) {
            var _props$onValidate5;
            (_props$onValidate5 = props.onValidate) === null || _props$onValidate5 === void 0 || _props$onValidate5.call(props, {
              type: "CUSTOM_BEFORE_UPLOAD",
              files: beforeUploadErrorFiles
            });
          }
        }
        if (autoUpload) {
          setToUploadFiles(tmpWaitingFiles);
          uploadFiles(tmpWaitingFiles);
        } else {
          handleNotAutoUpload(tmpWaitingFiles);
        }
      }
    });
    inputRef.current.value = null;
  };
  var onNormalFileChange = function onNormalFileChange(e) {
    var fileList = getFileList(e.target.files);
    onFileChange === null || onFileChange === void 0 || onFileChange(fileList);
  };
  function onDragFileChange(files) {
    onFileChange === null || onFileChange === void 0 || onFileChange(files);
  }
  var onPasteFileChange = function onPasteFileChange(e) {
    onFileChange === null || onFileChange === void 0 || onFileChange(_toConsumableArray(e.clipboardData.files));
  };
  function uploadFiles(toFiles) {
    var notUploadedFiles = uploadValue.filter(function (t2) {
      return t2.status !== "success";
    });
    var files = autoUpload ? toFiles : notUploadedFiles;
    if (!files || !files.length) return;
    xhrReq.current = [];
    setUploading(true);
    upload({
      action: props.action,
      method: props.method,
      headers: props.headers,
      name: props.name,
      withCredentials: props.withCredentials,
      uploadedFiles: uploadValue,
      toUploadFiles: files,
      multiple: props.multiple,
      isBatchUpload: isBatchUpload,
      autoUpload: autoUpload,
      uploadAllFilesInOneRequest: props.uploadAllFilesInOneRequest,
      useMockProgress: props.useMockProgress,
      data: props.data,
      mockProgressDuration: props.mockProgressDuration,
      requestMethod: props.requestMethod,
      formatRequest: props.formatRequest,
      formatResponse: props.formatResponse,
      onResponseProgress: function onResponseProgress(p) {
        return _onResponseProgress(p, toFiles);
      },
      onResponseSuccess: function onResponseSuccess(p) {
        return _onResponseSuccess(p, toFiles);
      },
      onResponseError: function onResponseError(p) {
        return _onResponseError(p, toFiles);
      },
      setXhrObject: function setXhrObject(xhr) {
        var _xhr$files$;
        if ((_xhr$files$ = xhr.files[0]) !== null && _xhr$files$ !== void 0 && _xhr$files$.raw && xhrReq.current.find(function (item) {
          return item.files[0].raw === xhr.files[0].raw;
        })) return;
        xhrReq.current = xhrReq.current.concat(xhr);
      }
    }).then(function (_ref) {
      var status = _ref.status,
        data = _ref.data,
        list = _ref.list,
        failedFiles = _ref.failedFiles;
      setUploading(false);
      if (status === "success") {
        var _props$onSuccess;
        if (props.autoUpload) {
          setUploadValue(_toConsumableArray(data.files), {
            trigger: "add",
            file: data.files[0]
          });
        }
        (_props$onSuccess = props.onSuccess) === null || _props$onSuccess === void 0 || _props$onSuccess.call(props, {
          fileList: data.files,
          currentFiles: files,
          file: files[0],
          results: list === null || list === void 0 ? void 0 : list.map(function (t2) {
            return t2.data;
          }),
          response: data.response || list.map(function (t2) {
            return t2.data.response;
          }),
          XMLHttpRequest: data.XMLHttpRequest
        });
        xhrReq.current = [];
      } else if (failedFiles !== null && failedFiles !== void 0 && failedFiles[0]) {
        var _props$onFail;
        (_props$onFail = props.onFail) === null || _props$onFail === void 0 || _props$onFail.call(props, {
          e: data.event,
          file: failedFiles[0],
          failedFiles: failedFiles,
          currentFiles: files,
          response: data.response,
          XMLHttpRequest: data.XMLHttpRequest
        });
      }
      if (autoUpload) {
        var _props$onWaitingUploa2;
        setToUploadFiles(failedFiles);
        (_props$onWaitingUploa2 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa2 === void 0 || _props$onWaitingUploa2.call(props, {
          files: failedFiles,
          trigger: "uploaded"
        });
      }
    });
  }
  function onRemove(p) {
    var _props$onRemove;
    setSizeOverLimitMessage("");
    var changePrams = {
      e: p.e,
      trigger: "remove",
      index: p.index,
      file: p.file
    };
    if (isBatchUpload || !props.multiple) {
      var _props$onWaitingUploa3;
      (_props$onWaitingUploa3 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa3 === void 0 || _props$onWaitingUploa3.call(props, {
        files: [],
        trigger: "remove"
      });
      setUploadValue([], changePrams);
      setToUploadFiles([]);
      xhrReq.current = [];
    } else if (!props.autoUpload) {
      uploadValue.splice(p.index, 1);
      setUploadValue(_toConsumableArray(uploadValue), changePrams);
    } else if (p.index < uploadValue.length) {
      uploadValue.splice(p.index, 1);
      setUploadValue(_toConsumableArray(uploadValue), changePrams);
    } else {
      var _props$onWaitingUploa4;
      var tmpFiles = _toConsumableArray(toUploadFiles);
      tmpFiles.splice(p.index - uploadValue.length, 1);
      setToUploadFiles(_toConsumableArray(tmpFiles));
      (_props$onWaitingUploa4 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa4 === void 0 || _props$onWaitingUploa4.call(props, {
        files: _toConsumableArray(tmpFiles),
        trigger: "remove"
      });
    }
    (_props$onRemove = props.onRemove) === null || _props$onRemove === void 0 || _props$onRemove.call(props, p);
  }
  var triggerUpload = function triggerUpload() {
    if (disabled || !inputRef.current) return;
    inputRef.current.click();
  };
  var cancelUpload = function cancelUpload(context) {
    var _xhrReq$current, _props$onCancelUpload;
    (_xhrReq$current = xhrReq.current) === null || _xhrReq$current === void 0 || _xhrReq$current.forEach(function (item) {
      var _item$xhrReq;
      (_item$xhrReq = item.xhrReq) === null || _item$xhrReq === void 0 || _item$xhrReq.abort();
    });
    setUploading(false);
    if (autoUpload) {
      setToUploadFiles([]);
    } else {
      setUploadValue(uploadValue.map(function (item) {
        if (item.status !== "success") {
          return _objectSpread(_objectSpread({}, item), {}, {
            status: "waiting"
          });
        }
        return item;
      }), {
        trigger: "abort"
      });
    }
    if (context !== null && context !== void 0 && context.file && !autoUpload) {
      onRemove === null || onRemove === void 0 || onRemove({
        file: context.file,
        e: context.e,
        index: 0
      });
    }
    (_props$onCancelUpload = props.onCancelUpload) === null || _props$onCancelUpload === void 0 || _props$onCancelUpload.call(props);
  };
  useEffect(function () {
    if (!Array.isArray(uploadValue)) {
      setUploadValue([], {
        trigger: "default"
      });
    }
  }, [uploadValue]);
  return {
    t: t,
    locale: locale,
    classPrefix: classPrefix,
    triggerUploadText: triggerUploadText,
    toUploadFiles: toUploadFiles,
    uploadValue: uploadValue,
    displayFiles: displayFiles,
    sizeOverLimitMessage: sizeOverLimitMessage,
    uploading: uploading,
    tipsClasses: tipsClasses,
    errorClasses: errorClasses,
    placeholderClass: placeholderClass,
    inputRef: inputRef,
    disabled: disabled,
    xhrReq: xhrReq,
    uploadFilePercent: uploadFilePercent,
    uploadFiles: uploadFiles,
    onFileChange: onFileChange,
    onNormalFileChange: onNormalFileChange,
    onDragFileChange: onDragFileChange,
    onPasteFileChange: onPasteFileChange,
    onRemove: onRemove,
    triggerUpload: triggerUpload,
    cancelUpload: cancelUpload
  };
}

export { useUpload as default };
//# sourceMappingURL=useUpload.js.map
